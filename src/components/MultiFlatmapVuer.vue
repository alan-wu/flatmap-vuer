<template>
  <div class="multi-container">
    <div style="position:absolute;z-index:10;">
      <el-popover content="Select a species" placement="right" 
        :appendToBody=false trigger="manual" popper-class="flatmap-popper" v-model="helpMode" ref="selectPopover">
      </el-popover>
        <el-select
          id="flatmap-select"
          :popper-append-to-body="appendToBody"
          v-model="activeSpecies"
          placeholder="Select"
          class="select-box"
          popper-class="flatmap_dropdown"
          @change="flatmapChanged"
          v-popover:selectPopover
        >
          <el-option v-for="(item, key) in speciesList" :key="key" :label="key" :value="key">
            <el-row>
              <el-col :span="8"><i :class="item.iconClass"></i></el-col>
              <el-col :span="12">{{ key }}</el-col>
            </el-row>
          </el-option>
        </el-select>
      
    </div>
    <FlatmapVuer
      v-for="(item, key) in speciesList"
      :key="key"
      :showLayer="showLayer"
      v-show="activeSpecies==key"
      :entry="item.taxo"
      :displayWarning="item.displayWarning"
      :warningMessage="warningMessage"
      :ref="key"
      @resource-selected="FlatmapSelected"
      @ready="FlatmapReady"
      :featureInfo="featureInfo"
      :minZoom="minZoom"
      :pathControls="pathControls"
      :searchable="searchable"
      :helpMode="helpMode"
      :renderAtMounted="renderAtMounted"
      :displayMinimap="displayMinimap"
      style="height:100%"
      :flatmapAPI="flatmapAPI"
      :mapManager="mapManager"
    />
  </div>
</template>


<script>
/* eslint-disable no-alert, no-console */
import Vue from "vue";
import FlatmapVuer from "./FlatmapVuer.vue";
import { Col, Option, Select, Row, Popover } from "element-ui";  
import lang from "element-ui/lib/locale/lang/en";
import locale from "element-ui/lib/locale";
locale.use(lang);
Vue.use(Col);
Vue.use(Row);
Vue.use(Option);
Vue.use(Select);
Vue.use(Popover)


export default {
  name: "MultiFlatmapVuer",
  components: {
    FlatmapVuer
  },
  methods: {
    FlatmapSelected: function(resource) {
      this.$emit("resource-selected", resource);
    },
    FlatmapReady: function(component) {
      this.$emit("ready", component);
    },
    getCoordinatesOfLastClick: function() {
      const flatmap = this.$refs[this.activeSpecies];
      if (flatmap && flatmap[0]) {
        return flatmap[0].getCoordinatesOfLastClick();
      }
      return undefined;
    },
    getCurrentFlatmap: function() {
      return this.$refs[this.activeSpecies][0];
    },
    showPopup: function(featureId, node, options) {
      let map = this.getCurrentFlatmap();
      map.showPopup(featureId, node, options);
    },
    showMarkerPopup: function(featureId, node, options) {
      let map = this.getCurrentFlatmap();
      map.showMarkerPopup(featureId, node, options);
    },
    flatmapChanged: function(species){
      if (this.activeSpecies != species) 
        this.activeSpecies = species;
      this.$refs[this.activeSpecies][0].createFlatmap();
      this.$emit('flatmapChanged', this.activeSpecies);
    },
        /**
     * Function used for getting the current states of the scene. This exported states 
     * can be imported using the importStates method.
     * 
     * @public
     */
    getState: function() {
      let state = {
        species: this.activeSpecies,
        state: undefined,
      };
      let map = this.getCurrentFlatmap();
      state.state = map.getState();
      return state;
    },
    /**
     * Function used for importing the states of the scene. This exported states 
     * can be imported using the read states method.
     * 
     * @public
     */
    setState: function(state) {
      if (state) {
        if (state.species && state.species !== this.activeSpecies) {
          this.activeSpecies = state.species;
          if (state.state) {
            //Wait for next tick when the refs are ready for rendering
            this.$nextTick(() => {
              this.$refs[this.activeSpecies][0].createFlatmap(state.state);
              this.$emit('flatmapChanged', this.activeSpecies);
            })
          }
        } else if (state.state) {
          let map = this.getCurrentFlatmap();
          map.setState(state.state);
        }
      }
    },
  },
  props: {
    showLayer: {
      type: Boolean,
      default: false
    },
    featureInfo: {
      type: Boolean,
      default: false
    },
    pathControls: {
      type: Boolean,
      default: true
    },
    searchable: {
      type: Boolean,
      default: false
    },
    /**
     * Initial species for the flatmap.
     * This value will be ignored if a valid state object is provided.
     */
    initial: {
      type: String,
      default: ""
    },
    minZoom: {
      type: Number,
      default: 4
    },
    renderAtMounted: {
      type: Boolean,
      default: false
    },
    helpMode: {
      type: Boolean,
      default: false
    },
    displayMinimap: {
      type: Boolean,
      default: false
    },
    warningMessage: {
      type: String,
      default: "Beta feature - under active development"
    },
    availableSpecies: {},
    /**
     * State containing state of the flatmap.
     */
    state: {
      type: Object,
      default: undefined,
    },
    /**
     * Specify the endpoint of the flatmap server.
     */
    flatmapAPI: {
      type: String,
      default: undefined
    },
  },
  data: function() {
    return {
      activeSpecies: undefined,
      appendToBody: false,
      mapManager: undefined,
      speciesList: {},
    };
  },
  watch: {
    state: {
      handler: function(state) {
        this.setState(state);
      },
      immediate: true,
      deep: true,
    }
  },
  created: function() {
    const flatmap = require("@dbrnz/flatmap-viewer");
    let endpoint = this.flatmapAPI;
    if (!endpoint)
      endpoint = "https://mapcore-demo.org/flatmaps/";
    this.mapManager = new flatmap.MapManager(endpoint);
    this.mapManager.allMaps().then(mapsArray => {
      for (const map in mapsArray) {
        if (this.availableSpecies) {
          for (const name in this.availableSpecies) {
            if (this.availableSpecies[name].taxo === mapsArray[map].describes) {
              this.speciesList[name] = this.availableSpecies[name];
            }
          }
        }
      }
      if (!this.state) {
        if (this.initial && this.speciesList[this.initial] !== undefined) {
          this.activeSpecies = this.initial;
        } else {
          this.activeSpecies = Object.keys(this.speciesList)[0];
        }
        this.$nextTick(() => {
          this.$refs[this.activeSpecies][0].createFlatmap();
        })
        
      }
    });
  },
};
</script>

<style scoped src="../styles/purple/select.css">
</style>
<style scoped src="../styles/purple/option.css">
</style>

<style scoped>
.multi-container {
  height: 100%;
  width: 100%;
}

.select-box {
  width: 124px;
  border-radius: 4px;
  border: solid 1px #8300bf;
  background-color: var(--white);
  font-weight: 500;
  color: #8300bf;
  margin-left: 17px;
  top: 54px;
  position: absolute;
}

.select-box >>> .el-input__inner {
  color: #8300bf;
  padding-top: 0.25em;
}

.flatmap_dropdown .el-select-dropdown__item {
  white-space: nowrap;
  font-family: Helvetica;
  text-align: left;

}

.flatmap_dropdown .el-select-dropdown__item.selected {
  color: #8300bf;
  font-weight: normal;
  font-family: Helvetica !important;
}

>>>.flatmap-popper {
  padding:9px 10px;
  min-width:150px;
  font-size:12px;
  color: #ffffff;
  background-color: #8300bf;
}
>>> .flatmap-popper .popper__arrow::after{
  border-right-color: #8300bf !important;
}
</style>


